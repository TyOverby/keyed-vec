#![feature(collections)]

use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};
use std::collections::BitSet;

static INSTANCE_ID: AtomicUsize = ATOMIC_USIZE_INIT;

// (instance, index)
pub struct Index(usize, usize);

/// IndexedVec is a vector with a unique approach to indices.
/// Once an item is added to the IndexedVec, a _unique_ index is returned.
/// This index is the only way that that element may be accessed, and it
/// is garunteed by the rust typesystem for there only to be one of these
/// indices at one point in time.
///
/// This means that we can perform operations that would otherwise be unsafe in
/// a perfectly safe maner.  For example, you can grab a mutable reference
/// to an element from an immutable IndexedVec.  This is hugely useful in
/// multithreaded environments.
///
/// Because the Index is garunteed to exist and point to a valid location in
/// the backing array, the implementation of IndexedVec can also do lookups
/// without bounds checking.
pub struct IndexedVec<T> {
    mem: Vec<T>,
    instance: usize,
    open: BitSet,
}

impl <T> IndexedVec<T> {
    /// Creates a new BoundedArray with a given size.
    pub fn new() -> IndexedVec<T> {
        IndexedVec::with_capacity(16)
    }
    pub fn with_capacity(capacity: usize) -> IndexedVec<T> {
        let instance = INSTANCE_ID.fetch_add(1, Ordering::Relaxed);
        IndexedVec {
            mem: Vec::with_capacity(capacity),
            instance: instance,
            open: BitSet::new()
        }
    }

    fn do_push(&mut self, value: T) -> Result<Index, T> {
        let len = self.mem.len();
        self.mem.push(value);
        Ok(Index(self.instance, len))
    }

    fn do_fill(&mut self, value: T) -> Result<Index, T> {
        use std::mem::{forget, swap};

        let hole = self.open.iter().nth(0);
        if let Some(h) = hole {
            let arr = self.mem.as_mut_slice();
            let mut val = value;
            unsafe {
                // This is safe because the only way that
                // `h` could get into the open set is by
                // being a valid index and being removed.
                swap(&mut val, arr.get_unchecked_mut(h));

                // This is safe because when `h` got pushed
                // into the open set, the contents were zeroed
                // so this value can not be destrucuted.
                forget(val);
            }
            Ok(Index(self.instance, h))
        } else {
            Err(value)
        }
    }

    /// Adds an element to the BoundedVec.
    ///
    /// This function prefers to fill up holes in the array
    /// left by removing other items.
    pub fn add(&mut self, value: T) -> Result<Index, T> {
        let value = match self.do_fill(value) {
            Ok(i) => return Ok(i),
            Err(v) => v
        };
        self.do_push(value)
    }

    /// Adds an element to the BoundedVec.
    ///
    /// This function prefers to add elements to the 'end' of the array
    /// before filling holes.
    pub fn push(&mut self, value: T) -> Result<Index, T> {
        let value = match self.do_push(value) {
            Ok(i) => return Ok(i),
            Err(v) => v
        };
        self.do_fill(value)
    }

    /// Returns a reference to an element in the array.
    pub fn get<'a, 'b, 'c: 'a + 'b>(&'a self, index: &'b Index) -> &'c T {
        use std::mem::transmute;
        let &Index(ins, i) = index;
        if ins != self.instance {
            panic!("get() called with index that wasn't generated by the
                    this BoundedArray.");
        }

        let arr: &'a [T] = &self.mem[..];

        unsafe {
            // Safe because we are increasing the lifetime, not decreasing it.
            transmute(
                // Safe because we know that this index is
                // occupied (beacause we generated it).
                arr.get_unchecked(i))

        }
    }

    /// Returns a mutable reference to an element in the array.
    pub fn get_mut<'a, 'b, 'c: 'a + 'b>(&'a self, index: &'b mut Index) -> &'c mut T {
        use std::mem::transmute;
        let &mut Index(ins, i) = index;
        if ins != self.instance {
            panic!("get_mut() called with index that wasn't generated by the
                    this BoundedArray.");
        }

        unsafe {
            // Safe because we are only accessing the location for which
            // we are the only one that can actually access it.
            let arr: &mut [T] = transmute(&self.mem[..]);

            // Safe because we are just using this to increase the lifetime
            // bound from 'b, to 'c, not.
            transmute(
                // Safe because we know that this index is
                // occupied (beacause we generated it).
                arr.get_unchecked_mut(i))
        }
    }

    /// Swaps the element at an index, returning the previous value.
    pub fn swap(&self, index: &mut Index, mut value: T) -> T {
        use std::mem::swap;
        swap(self.get_mut(index), &mut value);
        value
    }

    /// Remove the element stored at Index location, returning it.
    pub fn take(&mut self, index: Index) -> T {
        use std::mem::{zeroed, swap};
        let Index(ins, i) = index;
        let mut copy = Index(ins, i);

        let mut out = unsafe { zeroed() };

        {
            let inside = self.get_mut(&mut copy);
            swap(&mut out, inside);
        }

        self.open.insert(i);

        out
    }

    /// Removes the element stored at Index location, dropping it.
    pub fn remove(&mut self, index: Index) {
        self.take(index);
    }

    /// Returns the slice of memory that is backing this structure.
    ///
    /// This function is unsafe because it is possible that the slice will
    /// contain uninitialized or dropped values.
    pub unsafe fn as_slice(&mut self) -> &[T] {
        &self.mem[..]
    }

    /// Returns a mutable slice of memory that is backing this structure.
    ///
    /// This function is unsafe because it is possible that the slice will
    /// contain uninitialized or dropped values.
    pub unsafe fn as_mut_slice(&mut self) -> &mut [T] {
        &mut self.mem[..]
    }
}
